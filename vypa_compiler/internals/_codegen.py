#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Project name: Compiler Implementation for VYPlanguage Programming Language
# Authors: Adam MÃºdry (xmudry01), Daniel Paul (xpauld00)

import sys

from vypa_compiler.internals._utils import ExitCode
from vypa_compiler.internals._models import symbol_table, lookup_in_global_symtable, lookup_variable_in_symtable, Scope, Variable, Function, Class, Program
from vypa_compiler.internals._ast import Node
from vypa_compiler.internals._instructions import Instruction
from vypa_compiler.internals._code_templates import CodeTemplate

i = Instruction
t = CodeTemplate

PC = '$PC'
SP = '$SP'
FP = '$FP' # $0
PCrestoreR = '$1'
resultR = '$2'
exprR1 = '$3'
exprR2 = '$4'
chunkP = '$5'
miscR1 = '$6'
miscR2 = '$7'

class CodeGenerator:
    
    def __init__(self, roots: list[Node]):
        self.roots = roots
        self.header = []
        self.constants = []
        self.code = []
        self.current_function = None
        self.add_header() # Print header first
        self.add_line('ALIAS FP $0') 
        # SECTION WITH CONSTANTS
        self.add_line(i._jump('main')) # Jump to main
        
        # TODO: Generate functions

    def __str__(self) -> str:
        return self.stringify(self.header + self.constants + self.code)

    def add_line(self, line: str | list[str] | tuple[str], where=None):
        if where is None:
            where = self.code
        if isinstance(line, list) or isinstance(line, tuple):
            for l in line:
                where.append(l)
        elif isinstance(line, str):
            where.append(line)

    def stringify(self, part: list[str]) -> str:
        return '\n'.join(part)

    def print_code(self, output_file=sys.stdout):
        if output_file is sys.stdout or output_file is None:
            print(self.stringify(self.header + self.constants + self.code))
        else:
            with open(output_file, 'w') as f:
                f.write(self.stringify(self.header + self.constants + self.code))

    def add_header(self):
        self.add_line('#! /bin/vypint', self.header)
        self.add_line('# VYPcode: 1.0', self.header)
        self.add_line(('# Generated by: xmudry01, xpauld00', '\n'), self.header)

    def push_scope(self):
        symbol_table.append(Scope()) 
    
    def pop_scope(self):
        symbol_table.pop()        

    def generate(self):
        for root in self.roots:
            self.push_scope()
            self.generate_code(root)
            self.pop_scope()

        self.add_line(['\n', i._label('__END')])

    def generate_code(self, ast: Node):

        if ast is None:
            return

        print(repr(ast))

        if ast.name == 'root':
            if ast.type == 'Function':
                self.current_function = ast.value
                # Function header
                self.add_line([
                    f"# Function: {ast.value}",
                    i._label(ast.value),
                    t._inc_reg(SP),
                    i._set(FP, SP)
                ])
                
                # Load parameters
                parameters = lookup_in_global_symtable(self.current_function).arguments
                for param in parameters:
                    self.add_line([
                        t._declare_variable(param.var_type, param.name),
                        t._load_variable(param.name, -(len(parameters) + 3))
                    ])

                self.generate_code(ast.left) # ?? Always None
                self.generate_code(ast.right)
                
        elif ast.name == 'Statement-scope':
            self.generate_code(ast.right)
        
        elif ast.name == 'Statement':
            self.generate_code(ast.left)
            self.generate_code(ast.right)

        elif ast.name == 'Variable-definition':
            self.add_line(
                t._declare_variable(ast.type, ast.value)
            )
            self.generate_code(ast.left)
        
        elif ast.name == '=':
            self.generate_code(ast.right)
            self.add_line(
                t._assign_variable(ast.left.value)
            )

        elif ast.name == 'Identifier':
            self.add_line(
                t._push_identifier(ast.value)
            )
            return ast
        
        elif ast.name == 'Int-Literal':
            self.add_line(
                t._literal_int(ast.value)   
            )
            return ast

        elif ast.name == 'String-Literal':
            self.add_line(
                t._literal_string(ast.value)   
            )
            return ast

        elif ast.name == 'Function-call':
            if ast.value == 'print':
                params = self.generate_code(ast.right)
                self.add_line(
                    t._print(params)
                )
            
            elif ast.value == 'readInt':
                self.add_line(
                    t._read_int_stack()
                )
            
            elif ast.value == 'readString':
                self.add_line(
                    t._read_string_stack()
                )

            else:
                params = self.generate_code(ast.right)
                self.add_line(
                    t._func_call(ast.value, params)
                )

        elif ast.name == 'Expression-list':
            parameters = []
            returned_ast = self.generate_code(ast.left)
            if returned_ast is not None:
                parameters.append(returned_ast)
            returned_ast_parameters = self.generate_code(ast.right)
            if returned_ast_parameters is not None:
                parameters += returned_ast_parameters
            return parameters

        elif ast.name == 'Next-expression':
            parameters = []
            returned_ast = self.generate_code(ast.left)
            if returned_ast is not None:
                parameters.append(returned_ast)
            returned_ast_parameters = self.generate_code(ast.right)
            if returned_ast_parameters is not None:
                parameters += returned_ast_parameters
            return parameters
        
        elif ast.name == 'return':
            if ast.left:
                self.generate_code(ast.left)
            
            self.add_line(
                t._return(self.current_function)
            )

        elif ast.type == 'Binary':
            operation = ast.name

            # Check for type
            temp = ast
            while temp.left:
                temp = temp.left
            if temp.name == 'identifier':
                expr_type = lookup_variable_in_symtable(temp.value).var_type
            elif temp.name == 'String-Literal':
                expr_type = 'string'
            else:
                expr_type = 'int'

            # Postorder
            self.generate_code(ast.left) # Left 
            self.generate_code(ast.right) # Right
            self.add_line(
                t._binary_operation(operation, expr_type)
            ) # Root
        
            
                                                                                                                                                                                                