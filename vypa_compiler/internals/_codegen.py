#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Project name: Compiler Implementation for VYPlanguage Programming Language
# Authors: Adam MÃºdry (xmudry01), Daniel Paul (xpauld00)

import sys

from vypa_compiler.internals._utils import ExitCode
from vypa_compiler.internals._models import symbol_table, lookup_in_global_symtable, lookup_variable_in_symtable, Scope, Variable, Function, Class, Program
from vypa_compiler.internals._ast import Node
from vypa_compiler.internals._instructions import Instruction
from vypa_compiler.internals._code_templates import CodeTemplate

i = Instruction
t = CodeTemplate

SP = '$SP'
FP = '$FP'
PC = '$PC'
expressionResultReg1 = '$4'
expressionResultReg2 = '$5'
chunkP = '$6'
miscRegister = '$7'



class CodeGenerator:
    
    def __init__(self, roots: list[Node]):
        self.roots = roots
        self.header = []
        self.constants = []
        self.code = []
        self.add_header() # Print header first
        self.add_line('ALIAS FP $0') 
        # SECTION WITH CONSTANTS
        self.add_line(i._jump('main')) # Jump to main
        
        # TODO: Generate functions

    def __str__(self) -> str:
        return self.stringify(self.header + self.constants + self.code)

    def add_line(self, line: str | list[str] | tuple[str], where=None):
        if where is None:
            where = self.code
        if isinstance(line, list) or isinstance(line, tuple):
            for l in line:
                where.append(l)
        elif isinstance(line, str):
            where.append(line)

    def stringify(self, part: list[str]) -> str:
        return '\n'.join(part)

    def print_code(self, output_file=sys.stdout):
        if output_file is sys.stdout or output_file is None:
            print(self.stringify(self.header + self.constants + self.code))
        else:
            with open(output_file, 'w') as f:
                f.write(self.stringify(self.header + self.constants + self.code))

    def add_header(self):
        self.add_line('#! /bin/vypint', self.header)
        self.add_line('# VYPcode: 1.0', self.header)
        self.add_line(('# Generated by: xmudry01, xpauld00', '\n'), self.header)

    def push_scope(self):
        symbol_table.append(Scope()) 
    
    def pop_scope(self):
        symbol_table.pop()        

    def generate(self):
        for root in self.roots:
            self.generate_code(root)
        self.add_line(['\n', i._label('__END')])

    def traverse(self, ast: Node):
        if ast is not None:
            if ast.left is not None:
                self.traverse(ast.left)
            self.generate_code(ast)
            if ast.right is not None:
                self.traverse(ast.right)

    def generate_code(self, ast: Node):

        if ast is None:
            return

        print(repr(ast))

        if ast.name == 'root':
            if ast.type == 'Function':
                self.add_line([
                    f"# Function: {ast.value}",
                    i._label(ast.value),
                    t._inc_reg(SP),
                    i._set(FP, SP)
                ])

                self.generate_code(ast.left) # ?? Always None
                self.generate_code(ast.right)
                
        elif ast.name == 'Statement-scope':
            self.push_scope()
            self.generate_code(ast.right)
            self.pop_scope()
        
        elif ast.name == 'Statement':
            self.generate_code(ast.left)
            self.generate_code(ast.right)

        elif ast.name == 'Variable-definition':
            self.add_line(
                t._declare_variable(ast.type, ast.value)
            )
            self.generate_code(ast.left)
        
        elif ast.name == '=':
            self.generate_code(ast.right)
            self.add_line(
                t._assign_variable(ast.left.value)
            )

        elif ast.name == 'Identifier':
            return ast
        
        elif ast.name == 'Int-Literal':
            self.add_line(
                t._literal_int(ast.value)   
            )
            return ast

        elif ast.name == 'String-Literal':
            self.add_line(
                t._literal_string(ast.value)   
            )
            return ast

        elif ast.name == 'Function-call':
            if ast.value == 'print':
                params = self.generate_code(ast.right)
                self.add_line(
                    t._print(params)
                )
            
            if ast.value == 'readInt':
                self.add_line(
                    t._read_int_stack()
                )
            
            if ast.value == 'readString':
                self.add_line(
                    t._read_string_stack()
                )

        elif ast.name == 'Expression-list':
            parameters = []
            returned_ast = self.generate_code(ast.left)
            print(">>> list: ", returned_ast)
            if returned_ast is not None:
                parameters.append(returned_ast)
            returned_ast_parameters = self.generate_code(ast.right)
            if returned_ast_parameters is not None:
                parameters += returned_ast_parameters

            print(">>> params: ", parameters)
            return parameters

            # while ast.right and ast.right.name == 'Next-expression':
            #     returned_ast = self.generate_code(ast.left)
            #     if returned_ast is not None:
            #         parameters.append(returned_ast)
            #     ast = ast.right

        elif ast.name == 'Next-expression':
            parameters = []
            returned_ast = self.generate_code(ast.left)
            print(">>> next: ", returned_ast)
            if returned_ast is not None:
                parameters.append(returned_ast)
            returned_ast_parameters = self.generate_code(ast.right)
            if returned_ast_parameters is not None:
                parameters += returned_ast_parameters
            return parameters

        
            
                                                                                                                                                                                                