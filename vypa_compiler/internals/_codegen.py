#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Project name: Compiler Implementation for VYPlanguage Programming Language
# Authors: Adam MÃºdry (xmudry01), Daniel Paul (xpauld00)

from __future__ import annotations

import sys

from vypa_compiler.internals._utils import ExitCode
from vypa_compiler.internals._models import symbol_table, lookup_in_global_symtable, lookup_variable_in_symtable, Scope, sematic_check_return_type, sematic_func_call_arguments_check, sematic_check_assign
from vypa_compiler.internals._ast import Node
from vypa_compiler.internals._instructions import Instruction
from vypa_compiler.internals._code_templates import CodeTemplate

# Instance variables for code generation
i = Instruction
t = CodeTemplate

PC = '$PC'
SP = '$SP'
FP = '$FP' # $0
PCrestoreR = '$1'
resultR = '$2'
exprR1 = '$3'
exprR2 = '$4'
chunkP = '$5'
miscR1 = '$6'
miscR2 = '$7'

# Represents a code generator
class CodeGenerator:
    
    def __init__(self, roots: list[Node]):
        self.roots = roots
        self.header = []
        self.footer = []
        self.constants = []
        self.code = []
        self.end = [i._label('__END')]
        self.current_function = None

        self.add_header() # Print header first
        self.add_line('ALIAS FP $0') 
        # SECTION WITH CONSTANTS
        self.add_line((i._jump('main'), "")) # Jump to main
        
    def __str__(self) -> str:
        return self.stringify(self.header + self.constants + self.code + self.footer + self.end)

    # Adds a line to the final output to given list
    def add_line(self, line: str | list[str] | tuple[str], where=None):
        if where is None:
            where = self.code
        if isinstance(line, list) or isinstance(line, tuple):
            for l in line:
                where.append(l)
        elif isinstance(line, str):
            where.append(line)

    def stringify(self, part: list[str]) -> str:
        return '\n'.join(part)

    # Prints the VYPcode
    def print_code(self, output_file=sys.stdout):
        asm = self.header + self.constants + self.code + self.footer + self.end
        if output_file is sys.stdout or output_file is None:
            print(self.stringify(asm))
        else:
            with open(output_file, 'w') as f:
                f.write(self.stringify(asm))

    def add_header(self):
        self.add_line((
            '#! /bin/vypint',
            '# VYPcode: 1.0',
            '# Generated by: xmudry01, xpauld00', ""
        ), self.header)

    def push_scope(self):
        symbol_table.append(Scope()) 
    
    def pop_scope(self):
        symbol_table.pop()        

    # Generates VYPcode for each function
    def generate(self):
        for root in self.roots:
            self.push_scope()
            self.generate_code(root)
            if lookup_in_global_symtable(self.current_function).return_type == 'void':
                self.add_line(t._return(self.current_function))
            self.pop_scope()

    # Generates a code for a function from abstract syntax tree
    def generate_code(self, ast: Node) -> Node:

        if ast is None:
            return

        print(repr(ast))

        if ast.name == 'root':
            if ast.type == 'Function':
                self.current_function = ast.value
                # Function header
                self.add_line([
                    f"# Function: {ast.value}",
                    i._label(ast.value),
                    t._inc_reg(SP),
                    i._set(FP, SP)
                ])
                
                # Load parameters
                parameters = lookup_in_global_symtable(self.current_function).arguments
                for param in parameters:
                    self.add_line([
                        t._declare_variable(param.var_type, param.name),
                        t._load_variable(param.name, -(len(parameters) + 3))
                    ])

                self.generate_code(ast.left) # ?? Always None
                self.generate_code(ast.right)

                return ast
                
        elif ast.name == 'Statement-scope':
            self.generate_code(ast.right)
            return ast
        
        elif ast.name == 'Statement':
            self.generate_code(ast.left)
            self.generate_code(ast.right)
            return ast

        elif ast.name == 'Variable-definition':
            self.add_line(
                t._declare_variable(ast.type, ast.value)
            )
            self.generate_code(ast.left)
            return ast
        
        elif ast.name == '=':
            sematic_check_assign(ast)
            self.generate_code(ast.right)
            self.add_line(
                t._assign_variable(ast.left.value)
            )
            return ast

        elif ast.name == 'Identifier':
            self.add_line(
                t._push_identifier(ast.value)
            )
            return ast
        
        elif ast.name == 'Int-Literal':
            self.add_line(
                t._literal_int(ast.value)   
            )
            return ast

        elif ast.name == 'String-Literal':
            self.add_line(
                t._literal_string(ast.value)   
            )
            return ast

        elif ast.name == 'Function-call':
            if ast.value == 'print':
                params = self.generate_code(ast.right)

                self.add_line(
                    t._print(params)
                )
            
            elif ast.value == 'readInt':
                self.add_line(
                    t._read_int_stack()
                )
            
            elif ast.value == 'readString':
                self.add_line(
                    t._read_string_stack()
                )

            else:
                if ast.value == 'length':
                    self.add_line(t._length(), self.footer)
                elif ast.value == 'subStr':
                    self.add_line(t._substring(), self.footer)

                sematic_func_call_arguments_check(lookup_in_global_symtable(ast.value), ast)
                params = self.generate_code(ast.right)
                self.add_line(
                    t._func_call(ast.value, params)
                )

            return ast

        elif ast.name == 'Expression-list':
            parameters = []
            returned_ast = self.generate_code(ast.left)
            if returned_ast is not None:
                parameters.append(returned_ast)
            returned_ast_parameters = self.generate_code(ast.right)
            if returned_ast_parameters is not None:
                parameters += returned_ast_parameters
            return parameters

        elif ast.name == 'Next-expression':
            parameters = []
            returned_ast = self.generate_code(ast.left)
            if returned_ast is not None:
                parameters.append(returned_ast)
            returned_ast_parameters = self.generate_code(ast.right)
            if returned_ast_parameters is not None:
                parameters += returned_ast_parameters
            return parameters
        
        elif ast.name == 'return':
            if ast.left:
                sematic_check_return_type(lookup_in_global_symtable(self.current_function), ast)
                self.generate_code(ast.left)
            
            self.add_line(
                t._return(self.current_function)
            )
            return ast
        elif ast.type == 'Unary':
            self.generate_code(ast.right)
            self.add_line(
                t._unary_arithmetic_op(ast.name)
            )
        elif ast.type == 'Binary':
            operation = ast.name

            # Check for type
            temp = ast
            while temp.left:
                temp = temp.left
            if temp.name == 'Identifier':
                lookup = lookup_variable_in_symtable(temp.value)
                expr_type = lookup.var_type
            elif temp.name == 'String-Literal':
                expr_type = 'string'
            else:
                expr_type = 'int'

            # Postorder
            self.generate_code(ast.left) # Left 
            self.generate_code(ast.right) # Right

            if operation == '+' and expr_type == 'string':
                self.add_line(t._concat(), self.footer)

            self.add_line(
                t._binary_operation(operation, expr_type)
            ) # Root

            return ast

        elif ast.name == 'if':
            # Generate expression
            self.generate_code(ast.left)
            #generate if_else
            self.add_line(
                t._if_start()
            )
            self.generate_code(ast.right)

            return ast

        elif ast.name == 'else':
            # Generate if body
            self.push_scope()
            self.generate_code(ast.left)
            self.pop_scope()

            self.add_line(
                t._if_end()
            )                 

            #Generate else body
            self.push_scope()
            self.generate_code(ast.right)
            self.pop_scope()           

            self.add_line(
                t._else_end()
            )

            return ast      

        elif ast.name == 'while':
            self.add_line(
                t._start_while()
            )                   
            self.generate_code(ast.left)
            self.add_line(
                t._evaluate_while()
            )                    
            self.push_scope()
            self.generate_code(ast.right)
            self.pop_scope()
            self.add_line(
                t._end_while()
            )  
            return ast
      
        elif ast.name == 'Expression-cast':
            if ast.left.value == 'string':
                self.generate_code(ast.right)
                self.add_line(
                    t._cast_int_to_str()
                )     
            return ast.right                                 